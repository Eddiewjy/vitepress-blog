---
updateTime: "2025-02-22 19:48"
---

# **浏览器缓存机制详解**

浏览器缓存机制通过减少重复请求和网络传输，显著提升网页加载速度和用户体验，核心分为 **强缓存** 和 **协商缓存** 两个阶段。

---

#### **1. 强缓存（无需请求服务器）**

浏览器直接判断本地缓存是否有效，若有效则直接使用缓存，**不发送请求**。通过以下响应头控制：

- **`Cache-Control`（HTTP/1.1，优先级高）**

  - `max-age=3600`：资源有效期（秒），如 `max-age=31536000`（1年）。
  - `public`：允许代理服务器缓存。
  - `private`：仅浏览器缓存。
  - `no-cache`：强制协商缓存（跳过强缓存）。
  - `no-store`：彻底禁用缓存。

- **`Expires`（HTTP/1.0，优先级低）**
  - 指定过期时间（如 `Expires: Wed, 21 Oct 2025 07:28:00 GMT`），受客户端本地时间影响，可能不准确。

**强缓存流程**：

1. 浏览器请求资源时，检查 `Cache-Control`/`Expires`。
2. 若未过期，直接使用本地缓存（状态码 `200 (from disk cache)` 或 `200 (from memory cache)`）。
3. 若过期，进入协商缓存阶段。

---

#### **2. 协商缓存（需请求服务器验证）**

当强缓存失效时，浏览器携带缓存标识向服务器验证资源是否变化。若未变化，返回 `304 Not Modified`，否则返回新资源。通过以下头字段控制：

- **`Last-Modified`（服务器时间） & `If-Modified-Since`（浏览器时间）**

  - 服务器返回资源时，添加 `Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT`。
  - 浏览器下次请求时，携带 `If-Modified-Since: [Last-Modified的值]`。
  - **缺点**：
    - 时间精度仅到秒，1秒内多次修改无法识别。
    - 文件内容未变但修改时间变化（如重新生成）会导致无效请求。

- **`ETag`（文件哈希值） & `If-None-Match`**
  - 服务器返回资源时，生成唯一哈希值（如 `ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"`）。
  - 浏览器下次请求时，携带 `If-None-Match: [ETag的值]`。
  - **优点**：精准判断内容变化，解决 `Last-Modified` 的缺陷。

**协商缓存流程**：  
4. 浏览器携带 `If-Modified-Since` 或 `If-None-Match` 发起请求。  
5. 服务器对比资源是否变化：

- 未变化 → 返回 `304`，浏览器使用本地缓存。
- 已变化 → 返回 `200` + 新资源 + 更新缓存头。

---

#### **3. 缓存位置**

浏览器缓存可能存储在两处：

- **Memory Cache**：内存缓存，快速读取，标签页关闭后释放（如小图片、JS文件）。
- **Disk Cache**：磁盘缓存，持久化存储，容量大但读取较慢（如大文件、CSS）。

---

#### **4. 实际应用策略**

- **静态资源（JS/CSS/图片）**：
  - 强缓存 + 文件名哈希（如 `app.a3b4c5.js`），内容变化后哈希值改变，触发重新请求。
- **HTML 文件**：
  - 协商缓存（`Cache-Control: no-cache`），确保页面内容及时更新。
- **API 请求**：
  - 根据需求设置 `Cache-Control`，如短时间缓存（`max-age=60`）。

---

#### **总结**

- **强缓存**：速度快，但过期前无法获取新资源。
- **协商缓存**：准确性高，但需网络请求验证。
- **最佳实践**：结合文件名哈希和缓存头，平衡性能与实时性。

---

# **浏览器渲染机制详解**

浏览器渲染机制是将 HTML、CSS 和 JavaScript 代码转换为用户可视界面的过程，分为 **关键步骤** 和 **优化策略** 两部分。以下是核心流程与细节：

#### **一、关键渲染流程（Critical Rendering Path）**

从接收资源到像素显示，浏览器依次执行以下步骤：

1. **解析 HTML → 构建 DOM 树**

   - 解析 HTML 标签，生成 **DOM 树**（Document Object Model）。
   - **遇到 `<script>` 标签会阻塞 DOM 解析**（除非标记 `async` 或 `defer`）。

2. **解析 CSS → 构建 CSSOM 树**

   - 解析 CSS 规则，生成 **CSSOM 树**（CSS Object Model）。
   - **CSS 是阻塞渲染的资源**，未加载完的 CSS 会阻塞页面渲染。

3. **合并 DOM + CSSOM → 生成渲染树（Render Tree）**

   - 渲染树仅包含可见节点（如排除 `display: none` 的元素）。
   - 每个节点关联对应的 CSS 样式。

4. **布局（Layout/Reflow）**

   - 计算渲染树中节点的几何信息（位置、尺寸）。
   - **首次布局称为“回流”**，后续布局可能由 JS 操作或样式变化触发。

5. **绘制（Paint）**

   - 将布局结果转换为屏幕上的像素（填充颜色、文本等）。
   - 多个图层可能分阶段绘制。

6. **合成（Composite）**
   - 将不同图层（如 `transform` 元素）合并为最终屏幕图像。
   - 合成阶段利用 GPU 加速，性能开销最小。

---

#### **二、关键性能优化点**

##### **1. 避免渲染阻塞**

- **CSS**：
  - 内联关键 CSS（Critical CSS），异步加载非关键 CSS。
  - 避免使用 `@import`（增加串行加载时间）。
- **JavaScript**：
  - 使用 `async` 或 `defer` 延迟脚本执行。
  - 减少 DOM 操作频率，批量修改样式或布局。

##### **2. 减少回流（Reflow）与重绘（Repaint）**

- **触发回流的操作**：
  - 修改元素尺寸（`width`、`height`）、位置（`margin`、`padding`）。
  - 调整窗口大小、读取布局属性（如 `offsetHeight`）。
- **优化策略**：
  - 使用 `transform` 和 `opacity` 实现动画（跳过布局和绘制，直接合成）。
  - 通过 `documentFragment` 批量操作 DOM。
  - 避免在循环中读取布局属性（如先读取后批量写入）。

##### **3. 分层与 GPU 加速**

- **合成层（Composite Layer）**：
  - 浏览器将特定元素（如 `will-change: transform`）提升为独立图层。
  - 图层独立渲染，减少重新绘制范围。
- **适用场景**：
  - 复杂动画、滚动效果、`<video>` 或 `<canvas>` 元素。

---

#### **三、渲染流程示例**

假设修改一个元素的背景颜色：

1. **JavaScript**：执行 `element.style.backgroundColor = "red"`。
2. **样式计算**：更新元素的 CSSOM。
3. **布局**：是否需要重新计算布局？本例中不需要（颜色变化不影响尺寸/位置）。
4. **绘制**：重新绘制受影响区域。
5. **合成**：若元素是独立图层，直接合成新像素。

---

#### **四、开发者工具分析**

- **Chrome DevTools > Performance**：
  - 录制页面加载过程，分析各阶段耗时（如 Layout、Paint）。
- **Layers 面板**：
  - 查看页面分层情况，定位不必要的图层提升。

---

#### **五、最佳实践总结**

1. **最小化关键资源**：压缩 HTML/CSS/JS，内联关键 CSS。
2. **减少重排与重绘**：使用 CSS3 动画、批量 DOM 操作。
3. **利用 GPU 加速**：合理使用 `transform` 和 `opacity`。
4. **优化 JavaScript 执行**：避免长任务阻塞主线程，使用 `requestAnimationFrame`。
