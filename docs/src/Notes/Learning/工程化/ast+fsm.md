::: tip
代码本质--字符串
:::

## AST 抽象语法树：

个人理解为js在解析代码时，先通过 **词法分析** ，将字符流分割为关键字，标识符，标点符号等存入token，tokens会进入一个列表，之后通过 **语法分析** 验证token是否合法，同时构建语法树结构。此时AST就产出了。
所谓AST无非就是包括了：type类型，start&end开始和终止位置，body参数
### 后续编译过程

ast形成后经过**语义分析**形成分析后的ast，之后交给`CodeGenerator` 形成New code

### 工作中使用编译原理的场景

公式编辑器，字符串复杂处理等，尤其是 **低代码平台**

## 有限状态机FSM：

需要确定 **输入**，**状态**，根据两者进行状态转换。

- 状态机类需要接受输入，根据转移规则转换状态。
- 转移规则应该考虑当前状态和输入，并根据它们确定下一个状态。如果当前状态和输入没有匹配的转移规则，则应该抛出一个异常。

基础设想：

- FSM 负责根据输入文本（Markdown）逐步进行状态转换，识别不同的 Markdown 元素。
- 当 FSM 识别到某个元素时，它会将该元素转化为一个 token （例如列表、标题、段落等）。
- 解析器最终会生成一个完整的 AST，该 AST 可以被进一步用于渲染成 HTML显示在页面上

开源框架分析：

- markdown-it/lib:

  - rule: 控制规则的增删改等操作
  - renderer: 将token解析为HTML
  - token: 管理操作token
  - parser_core: 定义一个核心处理器，通过规则链对输入状态进行处理。
  - parser_block: 将文本解析为块级元素。遍历输入文本，尝试应用一系列解析规则，
  - parser_inline: 处理块级元素的细节，将文本解析为行内元素，并更新解析状态 state。每个规则负责识别特定的内联标记，并相应地更新解析状态。

- showdown:
  子解析器（subParser）用于将Markdown文本的特定部分转换为HTML。每个子解析器负责处理Markdown中的一种或多种语法元素，例如段落、标题、列表等。通过分解使得处理更加高效。
