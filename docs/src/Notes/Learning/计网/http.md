# HTTP/1.1

## 优点

- 简单易用
- 灵活易拓展（应用层之下可以拓展）
- 跨平台

## 缺点

- 无状态
  这是一个双刃剑，好处是减轻服务器负担，坏处就是关联操作变得复杂，比如鉴权就额外需要传token，进而衍生出了令人痛苦的cookie八股（）
- 不安全
  明文传输相当于在网上裸奔，此时就需要引入 SSL/TLS 层
- 队头阻塞
  值得一提的是管道化技术解决了 **请求** 的队头阻塞，但是没有解决 **响应** 的队头阻塞。也就是请求可以并行，但是响应还是串行的

# HTTPS

简而言之就是在tcp之上添加了 SSL/TLS 层这么一个middleware，多了握手加密

# HTTP/2

http/2相对http/1.1的几个变化主要集中在报文的传输格式

## 头部压缩

原来的 Header+Body 结构对header并没有优化，h2就采用了`HPACK`算法来压缩头部，减少传输的字节数

- 静态表 （可以理解为热🔥点哈希表🤔）
  预定义的头部表，包含了常用的头部字段
- 动态表
  补足静态表罢了😆，静态表没包含的字段在这补充客户端和服务端都可以动态添加新的头部字段到动态表中
- 哈夫曼编码
  对头部字段进行Huff **man** !编码，进一步压缩数据

## 二进制帧🪡

h2把文本转成了二进制帧，不仅提高传输效率还能，能够利用位运算节省解析开销。帧一般分为两大类：

- 控制帧
  用于控制连接的建立和关闭，流量控制等
- 数据帧
  用于传输数据，最重要的有两个：
  - HEADERS
    用于传输请求和响应头部
  - DATA
    用于传输请求和响应体

## 并发请求

> 这个过程就可以类比为你从一家网店买了不同的商品，而你又在很多家网店购物，此时一个TCP连接就是一个专属于你的快递车，里面有很多快递盒，每个盒子是一个网店里的全部商品。

Stream：可以理解为快递盒，每个快递盒都有一个唯一的ID（steamID），快递盒里可以放多个快递（数据帧frame），每个快递盒可以放在快递小哥的车里独立传输。也就是一个连接上可以有多个流并行传输

补充：

- streamID通过奇偶来区分来自客户端还是服务器
- 标志位可以指定优先级

## 服务器推送

h2实现了服务器主动向客户端推送数据，例如客户端请求了一个html文件，服务器可以主动推送css和js文件，减少请求次数。

一个例子就是在stream1里返回html和发送css的声明，并且在stream2发送css文件，这个过程可以是`并发`的

# HTTP/3
